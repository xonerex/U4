/*
    Quine McCluskey Reduction Algorithm
    Author: Tennyson Demchuk
    09.17.2020
*/

#include <iostream>
#include <string>
#include <set>
#include <algorithm>

// Global vars
bool verbose = false;
bool report = false;
std::string reportFileName;
std::string expression;

// Function prototypes
std::string extractVars(std::string ex);                        // extract all unique variables in input expression and return as reverse sorted string
int hammingDistance(std::string imp1, std::string imp2);        // calculates hamming distance between two provided implicant
int numBitsHigh(std::string imp);                               // returns number of high bits in implicant (ie. 101 = 2 high bits)


/*
    This program takes a boolean expression in the form of "AB+AC+bC+...",
    calculates its truth table, then reduces the expression via Quine McCluskey
    reduction. The reduced expression is output to the console. A reduction
    report containing reduction and expression details can be generated by
    specifying 'generatereport OutputFileName' as an argument. Specify 'verbose' 
    as an argument to enable verbose mode.

    Expression syntax:
        A+B = A OR B
        AB = A AND B
        a = NOT A

    Usage: qm AB+AC+bC+... verbose generatereport outputfile.txt
    *Note: boolean expression must be provided as the first argument
    *Note: variables in expression are limited to a single character (ie. AB is two variables, A and B)
    *Note: variables must be alphabetic, limiting this program to a maximum of 26 unique vars
*/


int main(int argc, char* argv[]) {
    // Validate argument count
    if (argc < 2) {
        std::cerr << "Invalid Input. Boolean Expression Required.\nie. qm AB+AC+B'C\n";
        return -1;
    }
    else if (argc > 5) {        // max 5 args -> program name is first, -o and filename require 2
        std::cerr << "Invalid Input. Too many arguments provided.\n\
            Valid arguments are:\n\t\
                1) A boolean expression - ie. AB+AC+B^C\n\t\
                2) \"verbose\" - Enable verbose mode\n\t\
                3) \"generatereport\" - Write reduction report file, ie. generatereport reportFile.txt\n\
            Usage: qm AB+AC+bC verbose generatereport outputfile.txt\n\
            *Note: boolean expression must be provided as the first argument\n\
            *Note: variables in expression are limited to a single alphabetic character (ie. AB is two variables, A and B)\n\n\
            Expression syntax:\n\t\
                A+B = A OR B\n\t\
                AB = A AND B\n\t\
                a = NOT A\n";
        return -1;
    }

    // Validate argument contents
    std::string arg;

    expression = std::string(argv[1]);

    for (int i = 2; i < argc; i++) {
        arg = std::string(argv[i]);
        if (arg.compare("verbose") == 0) {                  // check for verbose mode
            verbose = true;
            std::cout << "Verbose mode enabled.\n";
            continue;
        }
        else if (arg.compare("generatereport") == 0) {      // check for report output
            report = true;
            reportFileName = std::string(argv[++i]);
            continue;
        }
        else {
            std::cerr << "Invalid argument \"" << arg << "\".\n\
                Valid arguments are:\n\t\
                    1) A boolean expression - ie. AB+AC+B^C\n\t\
                    2) \"verbose\" - Enable verbose mode\n\t\
                    3) \"generatereport\" - Write reduction report file, ie. generatereport reportFile.txt\n\
                Usage: qm AB+AC+bC verbose generatereport outputfile.txt\n\
                *Note: boolean expression must be provided as the first argument\n\
                *Note: variables in expression are limited to a single alphabetic character (ie. AB is two variables, A and B)\n\n\
                Expression syntax:\n\t\
                    A+B = A OR B\n\t\
                    AB = A AND B\n\t\
                    a = NOT A\n";
            return -1;
        }
    }

    // Local vars
    std::string varList;        // list of unique variables found in expression
    int numvars = 0;

    if (verbose) {
        if (report) std::cout << "Report file will be generated as " << reportFileName << std::endl;
        else std::cout << "No report file will be generated.\n";
        std::cout << "\nAnalyzing expression: " << expression << '\n';
    }

    // 1) Get list of variables in expression
    varList = extractVars(expression);  
    numvars = varList.length();    
    if (varList == "") {                    // validate varList/boolean expression
        std::cerr << "Invalid boolean expression \"" << expression << "\": No variables found.\n\
            Expression must be of the form AB+AC+bC+...\n\
            Variables must be alphabetic [A-Z] and are limited to a single character.\n\
            Expression syntax:\n\t\
                A+B = A OR B\n\t\
                AB = A AND B\n\t\
                a = NOT A\n";
    }
    if (verbose) {
        std::cout << numvars << " Variables in expression: ";
        for (char const& c : varList) {
            std::cout << c << " ";
        }
        std::cout << std::endl;
    }

    // 2) Construct truth table from expression vars
    //      width = # vars + 1 (vars + output [f])
    //      height = # combinations of var states = 2 ^ # vars

    return 0;
}

std::string extractVars(std::string ex) {
    std::string varList = "";
    std::set<char> vars;
    char var;

    for (char const& c : ex) {      // iterate expression
        if (isalpha(c)) {               // consider only alphumeric characters as vars
            var = toupper(c);           // remove NOT distinction from all vars
            vars.insert(var);
        }
    }
    for (auto v : vars) {           // iterate expressions in set and add to list
        varList += v;
    }

    std::sort(varList.begin(), varList.end(), std::greater<char>());      // sort vars in decreasing order (ie. BCDA -> DBCA)

    return varList;
}