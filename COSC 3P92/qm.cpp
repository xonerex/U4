/*
    Quine McCluskey Reduction Algorithm
    Author: Tennyson Demchuk
    09.17.2020
*/

#include <iostream>
#include <string>
#include <cmath>
#include <set>
#include <algorithm>
#include <unordered_map>
#include <vector>
#include <bitset>

// Global vars
bool verbose = false;                       // verbose mode flag
bool report = false;                        // generate report enabled flag
std::string reportFileName;                 // filename of report
std::string expression;                     // boolean expression
std::unordered_map<char, int> varMap;       // mapping from expression variable labels to variable values for evaluation

// Function prototypes
std::string processExp(std::string ex);                         // process expression - extract all unique variables in input expression and return as reverse sorted string
int hammingDistance(std::string imp1, std::string imp2);        // calculates hamming distance between two provided implicant
inline int numBitsHigh(std::string imp);                               // returns number of high bits in implicant (ie. 101 = 2 high bits)


/*
    This program takes a boolean expression in the form of "AB+AC+bC+...",
    calculates its truth table, then reduces the expression via Quine McCluskey
    reduction. The reduced expression is output to the console. A reduction
    report containing reduction and expression details can be generated by
    specifying 'generatereport OutputFileName' as an argument. Specify 'verbose' 
    as an argument to enable verbose mode.

    Expression syntax:
        A+B = A OR B
        AB = A AND B
        a = NOT A

    Usage: qm AB+AC+bC+... verbose generatereport outputfile.txt
    *Note: boolean expression must be provided as the first argument
    *Note: variables in expression are limited to a single character (ie. AB is two variables, A and B)
    *Note: variables must be alphabetic, limiting this program to a maximum of 26 unique vars
*/


int main(int argc, char* argv[]) {
    // Validate argument count
    if (argc < 2) {
        std::cerr << "Invalid Input. Boolean Expression Required.\nie. qm AB+AC+B'C\n";
        return -1;
    }
    else if (argc > 5) {        // max 5 args -> program name is first, -o and filename require 2
        std::cerr << "Invalid Input. Too many arguments provided.\n\
            Valid arguments are:\n\t\
                1) A boolean expression - ie. AB+AC+B^C\n\t\
                2) \"verbose\" - Enable verbose mode\n\t\
                3) \"generatereport\" - Write reduction report file, ie. generatereport reportFile.txt\n\
            Usage: qm AB+AC+bC verbose generatereport outputfile.txt\n\
            *Note: boolean expression must be provided as the first argument\n\
            *Note: variables in expression are limited to a single alphabetic character (ie. AB is two variables, A and B)\n\n\
            Expression syntax:\n\t\
                A+B = A OR B\n\t\
                AB = A AND B\n\t\
                a = NOT A\n";
        return -1;
    }

    // Validate argument contents
    std::string arg;

    expression = std::string(argv[1]);

    for (int i = 2; i < argc; i++) {
        arg = std::string(argv[i]);
        if (arg.compare("verbose") == 0) {                  // check for verbose mode
            verbose = true;
            std::cout << "Verbose mode enabled.\n";
            continue;
        }
        else if (arg.compare("generatereport") == 0) {      // check for report output
            report = true;
            reportFileName = std::string(argv[++i]);
            continue;
        }
        else {
            std::cerr << "Invalid argument \"" << arg << "\".\n\
                Valid arguments are:\n\t\
                    1) A boolean expression - ie. AB+AC+B^C\n\t\
                    2) \"verbose\" - Enable verbose mode\n\t\
                    3) \"generatereport\" - Write reduction report file, ie. generatereport reportFile.txt\n\
                Usage: qm AB+AC+bC verbose generatereport outputfile.txt\n\
                *Note: boolean expression must be provided as the first argument\n\
                *Note: variables in expression are limited to a single alphabetic character (ie. AB is two variables, A and B)\n\n\
                Expression syntax:\n\t\
                    A+B = A OR B\n\t\
                    AB = A AND B\n\t\
                    a = NOT A\n";
            return -1;
        }
    }

    // Local vars
    const int MAXBITS = 26;                         // maximum bits = maximum # of variables allowed -> 26 alphabetic characters = 26 maximum bits
    std::string varList;                            // list of unique variables found in expression
    int numvars = 0;                                // number of unique bits (variables) represented in expression
    int ttRows, ttCols;                             // truth table dimensions
    std::vector<std::string> implicants;            // list of implicants   [minterms = inputs that evaluate to 1]
    std::vector<std::vector<std::string>> impTable; // table of implicant groupings

    if (verbose) {
        if (report) std::cout << "Report file will be generated as " << reportFileName << std::endl;
        else std::cout << "No report file will be generated.\n";
        std::cout << "\nAnalyzing expression: " << expression << '\n';
    }

    // 1) Parse, process, and validate expression
    varList = processExp(expression);  
    numvars = varList.length();    
    if (varList == "") {                    // validate varList/boolean expression
        std::cerr << "Invalid boolean expression \"" << expression << "\": No variables found.\n\
            Expression must be of the form AB+AC+bC+...\n\
            Variables must be alphabetic [A-Z] and are limited to a single character.\n\
            Expression syntax:\n\t\
                A+B = A OR B\n\t\
                AB = A AND B\n\t\
                a = NOT A\n";
        return -1;
    }
    if (verbose) {
        std::cout << numvars << " variables in expression: ";
        for (char const& c : varList) {
            std::cout << c << " ";
        }
        std::cout << std::endl;
    }

    // 2) Construct truth table from expression vars
    //      width [cols] = # vars + 1 (vars + output [f])
    //      height [rows] = # combinations of var states = 2 ^ # vars
    ttRows = std::pow(2.0, numvars);
    ttCols = numvars + 1;
    std::string bits;
    char label, value;
    int evalBuffer, sum, fetched; 
    bool invert;

    if (verbose) {
        std::cout << "Generating truth table of size " << ttRows << " rows by " << ttCols << " columns.\n";
        for (auto c : varList) std::cout << c << ' ';
        std::cout << "| f\n";
    }
    for (int i=0; i < ttRows; i++) {    // iterate all combinations of bits
        bits = std::bitset<MAXBITS>(i).to_string();             // convert i value to binary representation as string padded to max bits
        bits = bits.substr((MAXBITS - numvars), MAXBITS);       // trim padding
        for (int j=0; j < numvars; j++) {                       // set var values in varMap
            label = varList[j];
            value = bits[j];
            if (verbose) std::cout << value << ' ';
            varMap[label] = (value == '1' ? 1 : 0);          
        }
    
        // evaluate expression
        evalBuffer = -1;
        sum = 0;
        for (char c : expression) {
            if (c == '+') {
                sum += evalBuffer;                                          // perform "OR"
                evalBuffer = -1;
                continue;
            } 
            invert = false;
            if (islower(c)) {
                invert = true;                                              // mark negation
                c = toupper(c);                                             // remove NOT distinction for map lookup
            }
            fetched = varMap.at(c);
            if (invert) fetched = (fetched == 1 ? 0 : 1);                   // perform negation           
            if (evalBuffer == -1) evalBuffer = fetched;
            else evalBuffer *= fetched;                                     // perform "AND"
        }
        sum += evalBuffer;
        if (sum > 0) {              // if inputs produce a 1, inputs represent an implicant of boolean expression
            sum = 1;
            implicants.push_back(bits);
        }
        if (verbose) std::cout << "| " << sum << '\n';
    }

    // 3) Process implicants iteratively to reduce to prime implicants. 
    //      Order them in increasing order of high bits (ie. 001 = 1 high bit, 101 = 2 high bits, etc...).
    //      Starting with the first implicant in group 0, find for each implicant another implicant with a hamming distance of 0
    //          -> If implicant i is in group n, then implicant j with hamming distance of 1 to i must be in group n+1. 
    //          -> For each implicant in group n, compare against each implicant in group n+1

    return 0;
}

std::string processExp(std::string ex) {
    std::string varList = "";
    std::set<char> vars;
    char var;

    for (char const& c : ex) {      // iterate expression and filter out vars into set [O(nlogn)]
        if (isalpha(c)) {               // consider only alphumeric characters as vars
            var = toupper(c);           // remove NOT distinction from all vars
            vars.insert(var);
        }
        else if (c != '+') {        // validate non alphabetic characters
            std::cerr << "Invalid boolean expression \"" << expression << "\": \"" << c << "\" is neither a valid variable or operator.\n\
                Expression must be of the form AB+AC+bC+...\n\
                Variables must be alphabetic [A-Z] and are limited to a single character.\n\
                Expression syntax:\n\t\
                    A+B = A OR B\n\t\
                    AB = A AND B\n\t\
                    a = NOT A\n";
            exit(EXIT_FAILURE);
        }
    }
    for (auto v : vars) {           // iterate expressions in set and add to list
        var = v;
        varList += var;
    }
    std::sort(varList.begin(), varList.end(), std::greater<char>());      // sort vars in decreasing order (ie. BCDA -> DBCA) [O(nlogn)]

    return varList;
}

inline int numBitsHigh(std::string imp) {
    int count = 0;
    for (char c : imp) {
        if (c == '1') count++;
    }
    return count;
}